\documentclass[]{report}   % list options between brackets

\usepackage{color}
\usepackage{graphicx}
%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
%% The amsthm package provides extended theorem environments
\usepackage{amsthm}
\usepackage{amsmath}

\usepackage{listings}


\newtheorem{axiom}{Axiom}

\newtheorem{proposition}{Proposition}


% type user-defined commands here
\usepackage[T1]{fontenc}

\usepackage{xcolor}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstdefinestyle{myScalastyle}{
  frame=tb,
  language=scala,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  frame=single,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
}
\newtheorem{claim1}{Claim}
%\newtheorem{lemma}{Lemma}
\newtheorem{dfn}{Definition}
\newtheorem{defn}{Definition}
%\newtheorem{definition}{Definition}
\newcommand{\ma}{\mathcal{A}}
\newcommand{\mb}{\mathcal{B}}
\newcommand{\he}{\hat{e}}
\newcommand{\sr}{\stackrel}
\newcommand{\ra}{\rightarrow}
\newcommand{\la}{\leftarrow}

\newcommand{\ignore}[1]{} % may contain useful stuff (that needs more work)
\newcommand{\full}[1]{} % use only for full version
\newcommand{\notfull}[1]{#1}
\newcommand{\rand}{\stackrel{R}{\leftarrow}}
\newcommand{\haya}{blue}
\newcommand{\amitabh}{purple}
\newcommand{\questions}{blue}
\newcommand{\defined}{\stackrel{\mbox{\tiny{def}}}{=}}
\newcommand{\mc}{\mathcal}
\newcommand{\ms}{\mathsf}
\newcommand{\txs}{\textsf}
\newcommand{\lea}{\leftarrow}
\newcommand{\rea}{\rightarrow}
\newcommand{\adv}{{\cal A} }
\def\kg{{\sf{Gen}}}
\def\enc{{\sf{Enc}}}
\def\dec{{\sf{Dec}}}
\newcommand{\btc}{\includegraphics[height=8pt]{assets/btc.jpg}}

\begin{document}

%\lstset{language=Scala}
%\begin{lstlisting}[style=myScalastyle]
%

\title{Scorex Tutorial}
\author{Alexander Chepurnoy}         
\date{June-August, 2016}
\maketitle

% \begin{abstract}  


\chapter{Executive Summary}

This paper describes the Scorex project and how it can be used to create blockchain protocols such as cryptocurrencies (Bitcoin). Scorex is a library written in Scala with loosely coupled components that can be used as the underlying framework for making applications using a blockchain (a type of decentralized consensus-based protocol). 
The intended audience is developers wanting to create or experiment with such applications. Some basic knowledge of cryptography, data structures and cryptocurrencies is required. Some programming background is also required to understand the code-snippets. For good explanation of cryptography primitives and protocols please refer to the foundational book of~\cite{katz2014introduction}. 

In order to understand Scorex, it is helpful to consider Bitcoin, Namecoin and Nxt as three distinct applications of blockchain. Scorex gives the underlying framework for developing any of the three apps (and several others) by writing a thin layer of code. 


[TODO: AC: we have more complex division now, fix the list below?]
The main components of Scorex are:
\begin{enumerate}
	\item Mechanism for creating a genesis block and subsequent blocks using some transferable tokens (transactions).
	\item Mechanism for forming consensus as to when a block is accepted in the blockchain (proof-of-work, proof-of-stake, etc).
	\item Mechanism for defining arbitrary rules as to when a token transfer is valid (Bitcoin UTXOs, NXT accounts, Namecoin domains).
\end{enumerate}


\section{Organization}


This document is organized as follows. In Chapter~\ref{building-blocks}, we describe basic building blocks of a blockchain system. In Chapter~\ref{impl}, we describe how the blocks are implemented in the Scorex framework. We provide code snippets in Scala language. No prior knowledge of the Scala language is required.


\chapter{Introduction}

If you have heard of blockchain then you have indirectly heard of Bitcoin, the decentralized peer-to-peer currency network with some fancy features such as the ability to transfer real value over virtual channels. This is because Bitcoin is the first widespread use of the blockchain, which is essentially a {\em decentralized tamper-resistant append-only database} of transactions (sometimes also referred to as a {\em ledger}). Let us elaborate on this in more detail in the following sections. 

\section{Blockchain and Boxes}


Define $F$ to be the set of mappings $\mathbb{Z}\times\mathbb{Z} \mapsto \{-1, 0, 1\}$ over the integers. 
Intuitively, each integer pair represents a `box' of type (public-key, amount). Each element from $F$ maps the pairs of such integers (i.e., all boxes) to one of three states: $-1, 0, 1$, indicating that the corresponding box is respectively {\em Unused} (never used), {\em Closed} (contains funds) and {\em Opened} (funds have been used).
A blockchain is an infinite sequence $f_0, f_1, f_2, \ldots \in F$ of functions from $F$ applied iteratively on $\mathbb{Z}$ such that: % each $f_i$ satisfies the following:
\begin{enumerate}
	\item $f_i \neq f_{i+1}$ (there must be at least one state change in the boxes).
	\item $\forall (x, y) \in \mathbb{Z}: f_i(x, y) \leq f_{i+1}(x, y)$ (state cannot decrease).
	\item $\forall (x, y) \in \mathbb{Z}: f_i(x, y)+1 \geq f_{i+1}(x, y)$ (state cannot increase > 1).
\end{enumerate}

$f_0$ is called the {\em genesis mapping} or {\em genesis state}. Each mapping $f_i$ represents a snapshot of the system at iteration $i$, denoted $f_i(\mathbb{Z})$, which indicates the state of each box. A {\em block} $i$ gives the deltas between two successive states $(f_{i+1}, f_{i})$ and is essentially defines a set of boxes to open and close. Formally, {\em block}$_{i}$ is the set $\{(x, y)|f_{i+1}(x, y)\neq f_i(x, y)\}$. The transformation rules ensure that there is a unique block for each iteration. While this is enough to define a generic blockchain, Bitcoin has some additional rules:

\begin{enumerate}
	\item For any block $b_{i}$, $$\sum_{(x, y)\in b_{i}} y\cdot f_{i+1}(x, y) +\sum_{(x, y)\in b_{i}} y\cdot f_{i}(x, y) \leq  r(i),$$ for some {\em reward} function $r$.
	
	Note that $\sum_{(x, y)\in b_{i}} y\cdot f_{i}(x, y)$ is the negative of the sum of amount in all the boxes to be closed in this iteration and $\sum_{(x, y)\in b_{i}} y\cdot f_{i+1}(x, y)$ is the sum for the boxes to be opened. Thus, the LHS is the amount of bitcoins `created' in this block minus the amount bitcoins `destroyed'. The inequality says that the net amount of bitcoins created in a block cannot be more than the reward. 
	\item For each box $(x, y)\in b_i$, there is a {\em transaction} that acts as the {\em witness} of opening or	closing that box. A transaction acts like a proof that a particular state change was authorized via some public key, which will be discussed in detail in the next chapter. 
\end{enumerate}

At any iteration $i$ of the blockchain, older snapshots $(f_0, f_1, f_2, \ldots)$ are considered tamper-resistant while fresh copies ($\ldots, f_{i-2}, f_{i-1}, f_i$) may be susceptible to deletion or tampering, depending on the computational power of the attacker. However, after the snapshot becomes sufficiently old, it can be considered as tamper-proof for all practical purposes. The rules of the protocol ensure that if all honest nodes start with the same initial state $f_0$ and apply the same blocks successively then they will have the same snapshots $f_i$ at any iteration $i$. The task here is to ensure that the blocks are always applied in the right order. This is a consensus problem, and is solved in Bitcoin using a concept called {\em proof-of-work} -- the solution to a hard puzzle. The idea is that not everyone gets to choose which block to apply to reach the next valid snapshot, but only by someone who has invested a large amount of computing power and provides the proof on a first-come-first-serve basis. Snapshots are connected -- each block is linked to the previous one via a cryptographic hash so that if someone else provides a proof-of-work and the network accepts it, then all existing work for ``winning'' this block is invalidated and the contenders have to start again with the newly accepted block as the starting point. To incentivize nodes to expend work, each accepted snapshot comes with some reward in the form of tokens generated (additional states that benefit the node solving the puzzle). 

The rules encoding state changes are hardwired into the peer-to-peer nodes so that once a majority of them are running the code and act honestly, we can be ensured that block updates follow the correct rules. Blockchain can tolerate a high number of corrupt nodes (those controlled by an attacker) -- close to 40\%. 

\paragraph{Transactions:} Transactions can also be seen as state changes authorized via private keys and validated by the corresponding public keys. The transaction can encode information pertaining to funds transfer (as in Bitcoin) or have additional information pertaining to the external world such as attaching a key-value pairs to a public key (as in Namecoin -- a decentralized DNS).
While Bitcoin seems to be the primary use of blockchain right now, other intriguing use cases such as Namecoin have also been presented. The most powerful of being programmable-blockchains. The idea is simple -- while in Bitcoin, the rules encoding the state changes pertain only to spending of funds, nothing prevents us from coming up with more complex rule that can encode some business logic. One such example, already mentioned, is Namecoin, which additionally has rules for reserving doman names and for transferring them. In all cases, the rules will be written in a language that the node understands and accepts (the grammar is hardwired into the node). 

The newer applications of blockchain are all based on how these rules can be written and how expressive the language is. For instance, Ethereum, another blockchain based protocol boasts of a Turing complete language in contrast to the tiny one that Bitcoin provides. The following summarizes the main proposals.

%
\begin{enumerate}
	\item {\em Bitcoin:} Decentralized currency. 
	
		{\em Advantages:} Decentralization of money, easy to store and spend.
		
		{\em Challenges:} Too much storage, wild price fluctuations, too much energy consumed, limited bandwidth of blocks, not suitable for micro-transactions.
	\item {\em Namecoin:} Decentralized DNS (stores {\em key} $\rightarrow$ {\em value} mappings). 

		{\em Advantages:} Decentralization of DNS, difficult to sensor or shut down.
		
		{\em Challenges:} Similar in design to Bitcoin; some similar challenges, low computing power so less attack resistant.
	
	\item {Ethereum:} Smart	contracts.
	
	  {\em Advantages:} Enable trustless computing via decentralization.		
		
		{\em Challenges:} Turing completeness causes complexity, may have security issues -- example DAO attack.
	
\end{enumerate}
%\section{Other Tutorials}
%
%``How the Bitcoin protocol actually works'' tutorial by Michael Nielsen~\cite{nielsen} define problems led to the creation of Bitcoin and how the cryptocurrency solved them. The original Bitcoin whitepaper by Satoshi Nakamoto~\cite{Nakamoto2008} still provides very good description of basic concepts of Bitcoin. Details of Bitcoin technicalities could be found in the ``Mastering Bitcoin'' book~\cite{antonopoulos2014mastering}.
%

\chapter{Overview of Bitcoin}

Although the bitcoin protocol is quite complex, only a few basic concepts are necessary to understand the idea. These are: {\em transaction}, {\em input}, {\em output}, {\em reference}, {\em block} and {\em confirmation}. We describe them below. Firstly note that in bitcoin, funds are exchanged between {\em addresses} which are %SHA256 
hashes of public keys\footnote{We use the terms `address' and `public key' interchangeably. The meaning will be clear from the context.} %Depending on the context, a symbol $A$ could refer to a public key or an address (the meaning will be clear from the usage). 


 
\section{Transaction} Roughly speaking, a transaction consists of a set of \emph{inputs} (source of funds) and \emph{outputs} (destination of funds). %The funds available at the inputs are pooled together and are available for transfer to the outputs. 
%The transaction specifies how much each output must get. 

\paragraph{Example:} 
Suppose Alice is the owner of address $A$ which received $x$ bitcoins in a previous transaction. She wants to send $y \leq x$ bitcoins to Bob's address $B$. %Note that $A$ might have received more bitcoins in other transactions, which could be combined together. For now we will focus only on how these $x$ bitcoins are spent. 
Alice constructs a transaction with $A$ as the input and $B$ as one of the outputs.
She also inserts $ref$, the reference to the previous transaction's output where $A$ received those $x$ bitcoins.
%\footnote{$ref$ is essentially a 32 bit hash of that older transaction along with the index of the output. This is used to prevent double-spending as explained in Section~\ref{v0}.} 
%The protocol requires that 
The entire amount $x$ must be transferred from $A$. %To satisfy this, 
Alice sends $y$ bitcoins to $B$, sets a transaction fee $t$ and sends the remaining amount $z = x-y-t$ to her {\em change address} $C$, which is the other output. % of the transaction. 
The change address is simply any address owned by Alice (possibly $A$). %, which she can use as input in a further transaction. 
The message 

$$\mbox{``{($ref$: remove $\btc x$ from $A$), (put $\btc y$ in $B$), (put $\btc z$ in $C$)}''}$$ is signed under $A$. 
%The above transaction assigns $\btc y$ from Alice's public key $A$ to Bob's public key $B$. 
%For the transaction to be valid, it must hold that $x \geq y+z$. (In general there can be several outputs as long as the sum of outputs is less than or equal to the input.) The transaction additionally has a verification condition which must pass for the funds to unlocked by $B$. Without loss of generality, we assume that the verification condition is ``Any funds leaving $B$ must be signed under $B$.'' More complex conditions can be inserted here. 

\paragraph{Notation:} We will use the following notation:
\begin{itemize}
	\item $X \stackrel{ref}{\rightarrow} x$ is the message ``($ref$: remove $\btc x$ from $X$)''. This is an input.
\item
$X \leftarrow x$ is the message ``put $\btc x$ in $X$''. This is an output.
\item
$\sigma_X(m)$ is signature on message $m$ under public key $X$. %That is, public key $X$ is used to verify the signature.
\end{itemize}
Alice's transaction is then $(m, \sigma_A(m))$, where $m  =  (A\stackrel{ref}{\rea} x, B \lea y, C \lea z)$. 

%\subsection{The Bitcoin Protocol (V0)} 
%\label{v0}
%\paragraph{Bitcoin protocol:} Here we give the bitcoin protocol (with some simplifications). This is Version  0.
 
 
\paragraph{Transactions:} The above scenario had a single input. In reality, 
a bitcoin transaction can have multiple inputs with no particular link between any source-destination pair. The entire transaction is signed under every input public key. The only requirement is that the sum of the funds at the inputs is greater than or equal to the sum of funds at the outputs. Any difference is considered a transaction fee. More formally, define $m$ to be the message
\[
M \defined (A_1\sr{ref_1}{\ra}x_1, A_2\sr{ref_2}{\ra}x_2, \ldots, A_n\sr{ref_n}{\ra}x_n, B_1\la y_1,
B_2\la y_2, \ldots, B_l\la y_l), 
\] 
where: $(A_1, x_1, ref_1), (A_2, x_2, ref_2),\ldots , (A_n, x_n, ref_n)$ are $n$ tuples each consisting of an address $A_i$, amount of funds $x_i$ and a reference to a previous transaction %'s (unspent) output 
where $A_i$ received $x_i$ bitcoins, and $(B_1, y_1), (B_2, y_2),\ldots, (B_l, y_l)$ are $l$ pairs of addresses and amount of funds. 
%\paragraph{Inputs and outputs:} In message $M$ above, define inputs and outputs as follows:
%\[\mbox{Inputs }\defined A_i\sr{ref_i}{\ra} x_i~~~~~~~~(1\leq i \leq n)\] 
%\[\mbox{Outputs }\defined B_i \la y_i~~~~~~~~(1\leq i \leq l)\]
A valid transaction $tx$ is a tuple: 
\begin{equation}\label{tx0}tx\defined (M, \sigma_{A_1}(M), \sigma_{A_2}(M), \ldots, \sigma_{A_n}(M))\end{equation} such that each signature $\sigma_{A_i}(M)$ verifies correctly and the following holds:
\begin{enumerate}
	\item $\sum_{i=1}^{l}y_i \leq \sum_{i=1}^{n}x_i$ 
	\item Each $ref_i$ for $1\leq i\leq n$ was never used in any prior transaction.
\end{enumerate}

The ordering of the signatures in $tx$ is determined from the ordering of messages inside $M$ (which is fixed due to the signatures).
\paragraph{Referencing outputs:} In future, when spending the funds from any of the outputs (say $B_i \la y_i$) of the above transaction, a reference $ref_{B_i\la y_i}$ to that output needs to be provided. %This reference is computed as follows. 
Let $tx$ be the string of Eqn.~\ref{tx0}. Then \[ref_{B_i\la y_i}\defined (Hash(tx), i)\]

%\paragraph{References are unique:} 
Because $ref$ is constructed from the hash of a previous transaction, it is guaranteed that two different transactions are distinct unless the outputs, input and $ref$ are identical (a forbidden scenario). Due to this, it is also guaranteed (with high probability) that the $ref$s generated by using hashes of two different transactions are also different. In fact, this is how bitcoin prevents double spending (see below). A $ref$ can be used in a transaction at most once. Bitcoin clients maintain a list of unused $ref$s to do this check.

\paragraph{Unspent outputs (and double-spends):} An unspent output is essentially an unused reference, one that has never been used in any transaction. The protocol design guarantees that references to two different outputs will be distinct (see above).
Each client maintains a set called `unspent outputs'. Each output of every transaction is added to this set, and removed when is it used as a reference in another transaction. A transaction with a reference not in this list is considered a double spend and is not processed. %Currently, the size of the entire unspent output set is less than 100 MB which can be maintained in memory.\footnote{\url{https://en.bitcoin.it/wiki/Scalability#Storage}}


\section{Processing Transactions}


A new transaction is valid if all the references are unused. If so, the transaction is accepted as {\em valid} but {\em unconfirmed}, and is relayed on the network. The clients add each such transaction to a pool of unconfirmed transactions. Unconfirmed transactions can be double-spent. Here we describe the validation process in more detail.
Recall that a transaction is equivalent to 
$$tx\defined (M, \sigma_{A_1}(M), \sigma_{A_2}(M), \ldots, \sigma_{A_n}(M)),$$ 
where $M$ is a message with the following semantics:
\[
M \defined (A_1\sr{ref_1}{\ra}x_1, A_2\sr{ref_2}{\ra}x_2, \ldots, A_n\sr{ref_n}{\ra}x_n, B_1\la y_1,
B_2\la y_2, \ldots, B_l\la y_l), 
\] 
each $\sigma_{A_i}(M)$ is a valid signature on $M$ under $A_i$ and the following holds:

\begin{enumerate}
	\item $\sum_{i=1}^{l}y_i \leq \sum_{i=1}^{n}x_i$.
	\item Each $ref_i$ for $1\leq i\leq n$ was never used in any prior transaction.
	%\item Each $\sigma_{A_i}(M)$ is a valid signature on $M$ under $A_i$.
\end{enumerate}

In reality, the inputs $A_1\sr{ref_1}{\ra}x_1$ are represented only using $ref_i$. The values $A_i$ and $x_i$ are obtained from a {\em UTXO database} that every client must maintain.\footnote{The inputs additionally include the public key corresponding to address $A_i$. We can assume that this key is part of the signature.} This database is a key-value store of type $ref_i \ra (A_i, x_i)$. Note that in order to validate transactions and participate in the protocol, maintaining this UTXO database is necessary. Once a node has bootstrapped and synced, it need not store the entire blockchain. It can store just the UTXO database (plus a few recent blocks to handle rollbacks), and keep updating this database as new blocks are mined. Thus, even if a node is not storing blocks, it must still parse every new block to update its UTXO database. Also note that a node that does not store the blockchain cannot help other new nodes to bootstrap.


It is helpful to consider each (unused) $ref_i$
%$A_1\sr{ref_1}{\ra}x_1$ 
above as a ``closed box'' with $x_i$ inside, and the act of using $ref_i$ in a transaction as ``opening the box'' and releasing $x_i$. A box can be opened at most once and the act of sending bitcoins to an address ($B_i\la y_i$) generates a new closed box with $y_i$ inside. 

The semantics of transactions are specified using some encoding and a DSL called {\em Script} (a stack-based language similar in design to Forth). 
A node validates transactions as follows.
%As a basic requirement, Script has the following instructions:

% verifying signature
% input script defines the steps to do (i.e., verify signature)
% output script defines how to create the new box

\begin{enumerate}
  \item	For each input $A_i\sr{ref_i}{\ra}x_i$ from $(A_1\sr{ref_1}{\ra}x_1, A_2\sr{ref_2}{\ra}x_2, \ldots, A_n\sr{ref_n}{\ra}x_n)$
	
	\begin{enumerate}
		\item Load signature $\sigma_i$ and public key $A_i$ into stack. 
		\item Using $ref_i$, find box $A_{i}\la x_i$ from the database of unopened boxes. This is the output of a transaction where $A_i$ received $x_i$ bitcoins. 
		\item The loaded box contains the amount to be released as well as ``unlocking instructions'', a sequence of Script operations that verify the above signature on $M$. This is also loaded on the stack and evaluated. The box is opened if the output of the program is True (non-zero).
	\end{enumerate}
	\item If all boxes are opened, then we create new boxes $B_i\la y_i$ as defined by the outputs, provided that the total amount released from boxes is more than or equal to the total amount in the newly created boxes. 
\end{enumerate}

The opened and created boxes are not immediately committed to the UTXO database. Rather, every node must wait for the network to ``confirm'' the changes implied by any given transaction.  
Transactions are confirmed in bulk such that all nodes quickly reach a consensus on which set of transactions to include in the next database update. 
To ensure consistency and fast consensus, not everyone gets to choose which transactions to commit but only those nodes who have a large amount of computing resources (called ``miners'').

 
\section{Confirming Transactions}
\label{sec:verify}
Miners are nodes that propose a set of transactions to commit along with a proof that they have put in a certain minimum amount of work (in the form of CPU cycles) after the last update. The network selects the first solution. 

Roughly, the process of confirming transactions is as follows: 
\begin{enumerate}
	\item A bunch of unconfirmed transactions along with one reward transaction %\footnote{The reward transaction has no inputs. It takes the fees and the block reward.} 
	(known as the \emph{coinbase transaction}) are combined into a `block'.
	\item Hash of the previous block $h_{pr}$ is added to the block. %(version, etc) %. , computed incremented from the last block and the SHA256 hash of the last block is added to the block.
	\item A nonce is added to the block.
	\item Hash%SHA256(SHA256
	($b$) %)
	 of the final block $b$ is computed. 	
\end{enumerate}

If the output of the hash contains at least a specified number of leading zeros, the puzzle is solved, otherwise the miner tries with different nonces until the puzzle is solved or some other miner broadcasts the solution of a puzzle for a block referencing $h_{pr}$. A correct solution implies that the corresponding block is `mined' and all transactions contained in it are confirmed.
%Assuming that $M$ solves the puzzle first, block $b$ is considered `mined' and is broadcast to the network for other clients to append it to their blockchains. After this the transaction is confirmed. 

\paragraph{Confirmations:} The number of confirmations of a transaction are the number of blocks in the blockchain that have been accepted by the network since the block that includes the transaction. The possibility of double-spending a transaction decreases exponentially with the number of confirmations. The default client requires 6 confirmations for normal transactions and 100 confirmations for reward transactions before they can be spent.  

\paragraph{Transaction pool management:} Each client maintains a pool of unverified (but valid) transactions. An element is removed from this pool when that transaction gets included in a mined block. This ensures that even if a transaction is not included in an immediate block, it is kept in the pool until it gets mined. If a transaction is not confirmed within 72 hours then it forgotten. 

%%\paragraph{Selecting a unique chain:} One of the issues in Bitcoin is to select the ``valid'' chain given more than one contender. It is conceivable that an attacker (or network failure) can cause two or more competing chains to be temporar
%
%simultaneously present and dividntire network, with some holding each version. %is able to generate a chain longer than the one that honest nodes hold. 

\section{Scalability}

Before discussing scalability, we describe the blockchain structure in more detail.

\textbf{Block Structure:} A block consists of a variable-size {\em payload} containing the actual transactions in a Merkle tree structure and a fixed-size {\em header} describing the payload. The header contains: 
\begin{enumerate}
	\item The root hash of the Merkle tree of transactions.
	\item The current block index and the previous block-header hash.
	\item The nonce, the corresponding difficulty level and a timestamp.
\end{enumerate}

Earlier we stated (for simplicity) that the PoW is computed as a hash of the entire block. However, this is not true. The PoW is computed only on the header and not the payload. This enables nodes to verify PoW using just header information, while the payload can be verified later via the root hash. 

\textbf{Why do we need to store?} As discussed earlier, at the minimum each node must store the unopened boxes in a UTXO database. Additionally, each node may store the entire blockchain starting from the genesis block to help other clients to bootstrap. 

[...]

\textbf{What can be pruned?} If all the closed boxes generated in a particular block have been opened, that block is not needed for validation (we need blocks to validate/proof that our UTXO database is valid). Thus we can only store the headers for those blocks.\footnote{However, in the existing protocol, we cannot prove to another node that all generated boxes in a pruned block have been used up. A proposal of {\em block-level aggregation} of transactions could allow that.}


[...]

\section{Security and Privacy} 

%Before describing se 

At the heart of Bitcoin is the concept of the blockchain, a distributed global ledger of transactions that each node holds. The goal of the protcol is to ensure {\em eventual consistency}; if the network is completely synchronized then all nodes will have an identical copy of the blockchain. Thus, the primary goal of Bitcoin is to select the ``valid'' chain given more than one contenders. 


\paragraph{Selecting a unique chain:} It is conceivable that an attacker (or network failure) can cause two or more competing chains to be temporarily (a {\em soft-fork}) or permanently (a {\em hard-fork}) present in the system. The nodes should be able to quickly reject the ``invalid'' one. The protocol selects the chain with the highest cumulative difficulty, rather then the longest one. 

\paragraph{Difficulty level adjustment:} Difficulty is a measure of the hardness of the puzzle and can be quantified by $x$, the maximum possible number representable with that many leading zeros. 
A difficulty level of $d$ implies that $d = 2^{256}/x$. Thus, the smaller $x$ is, the larger the difficulty. The difficulty is adjusted every 2016 blocks based on the time it took to find the previous 2016 blocks. At the desired rate of one block each 10 minutes, 2016 blocks would take exactly two weeks to find. If the previous 2016 blocks took more than two weeks to find, the difficulty is reduced. If they took less than two weeks, the difficulty is increased. The change in difficulty is in proportion to the amount of time over or under two weeks the previous 2016 blocks took to find.


\paragraph{Security Requirements:} For security, we require the following: (1) The inability of an attacker to send bitcoins from addresses whose private key is not known, (2) The inability of an attacker to double-spend bitcoins or reverse a transaction, and (3) The inability of an attacker to prevent some valid transactions from confirming. The first requirement is satisfied if the underlying signature scheme is existentially unforgeable. The second and third requirements, formalized respectively as {\em persistence} and {\em liveness} in~\cite{Garay2015}, can be achieved if the underlying proof-of-work (PoW) based consensus system satisfies the following two properties~\cite{Garay2015}:
\begin{enumerate}
	\item {\em Common prefix:} If all honest participants remove the top (newer) $k$ blocks from their chains for a large enough $k$ then all of them will share a common prefix. In other words, the chains held by honest miners will either be identical or be contained in the others.
	\item {\em Chain quality:} There is some minimal integer $\lambda\geq 1$ such that, if the combined computing power of honest parties is $\lambda$ times that of the adversary, then a non-negligible amount of blocks generated by honest parties will make it into the chain. 
\end{enumerate}

If the difficulty level is sufficiently high and the network synchronization time (time between a new block being injected and reaching all participants) is short compared to average block generation period (10 minutes in Bitcoin) then the protocol offers high security. On the other hand, security is weakened if any of the following conditions hold~\cite{Garay2015}:
(1) overall computing power is low, (2) blocks are generated too fast, or (3) network takes long time to synchronize. 

\paragraph{Attacks on Implementation:} Following are attacks specific to Bitcoin:
\begin{enumerate}
	\item {\em Reused R-values:} The underlying signatures ECDSA can be broken if the same randomness is used in two different signatures~\cite{reusedRvalues}. Thus, implementations must take additional care to use true randomness or message-specific one (computed as a hash of the message).
	%\item {\em Attack on cumulative difficulty:} Since the initial difficulty is small in the first two years of Bitcoin, a powerful attacker may be able to forge a chain longer than the current one  with higher cumulative difficulty. This attack becomes more difficult as the cumulative difficulty increases.
	\item {\em Centralization of mining:} If a majority of the mining power is concentrated in a few pools, then they can collude and attack bitcoin. Part of the reason for this threat is the susceptibility to ASIC mining~\cite{asic}.
	\item {\em Denial of service attacks:} Certain attacks are based on miners forcing other miners to skip block validation by generating large blocks or ones that require expensive verification. Thus, they could send wrong data that will result in other miners to later lose their work.
	\item {\em Malleability:} The signature encoding in Bitcoin is such that if a certain bits of the signature are toggled, the result is still a valid signature (this is due to the underlying ECDSA scheme). This allows miners to mine a transaction whose is different from the original, while keeping everything else (i.e., inputs/outputs) same. If a bitcoin service uses the transaction hash to monitor sent funds, then it could lose funds~\cite{gox}.
\end{enumerate}

\paragraph{Privacy:} The addresses serve as pseudonyms and provide some anonymity. However, bitcoin does not provide true anonymity because the inputs are linked to the previous outputs via a reference.



% dicuss about block size, bandwidth requirements
% discuss minimal state, why we need to store utxo
% why we need history

\chapter{A Blockchain System Design}             % chapter 2
\section{Introduction}     


Consider Bitcoin as an example. Peers are holding money in form of algorithmically issued tokens. They do not trust each other, and do not to seek for a trusted mediator. Instead, they are running a Bitcoin protocol which builds a blockchain, a type of {\em append-only database} (or log). Older data in the blockchain can be considered {\em tamper-resistant} because it is protected using a consensus build using {\em proof-of-work} (a solution to a exponentially hard puzzle that can be verified efficiently, once known). The design of the protocol is such that the puzzle becomes harder as the data gets older. However, freshly added data (i.e., the last few versions of the log) are considered potentially unstable. Double spends are prevented using this database because the entire transfer history of any satoshi can be traced back to the time it was created. Thus, for example, if Alice had sent all her satoshis to Bob, she can't send anything after that and before receiving them from other party.

Using the above idea, we can define a blockchain as a {\em prefix-immutable append log of non-conflicting authenticated events in a decentralized peer-to-peer network}. Let us now elaborate on what this means.

Simply said, there are peers do not trust each other. There is no any trusted party, only a protocol peers need to follow~(being effectively thrown away from the network otherwise). Peers are issuing authenticated~(signed) events of some semantics. For example, they are sending out signed payments. Or they are registering \(name \rightarrow value\) correspondences in a shared database~(certificates, domains). ``Prefix-immutable append log'' means all the peers following the protocol are agree on immutable prefix of events append log. That is, if we cut a suffix of some length from the log a peer holds, for each peer, same-size prefixes will be the same, with overwhelming probability. Events in the ordered prefix-immutable log must be non-conflicting in order to have flawless history.

Consider Bitcoin as an example. Peers are holding money in form of algorithmically issued tokens. They do not trust each other, and do not to seek for a trusted mediator. Instead, they are running a Bitcoin protocol which builds prefix-immutable append log containing token transfers. Last few versions of the log are considered potentially unstable, but before them the history is considered as irreversible. The payments history is flawless, so, for example, if Alice had sent all her tokens to Bob, she can't send anything after that and before receiving tokens from other party.

\subsection{Security of Bitcoin}

Like any multiparty protocol, Bitcoin needs {\em correctness} (`valid transactions' should go through) and {\em soundness} (`invalid transactions' must be blocked). Correctness is defined in terms of passive adversaries, who behave according to protocol and do not attempt deviate. 

%We will discuss how correctness 
%Correctness is trivially guaranteed because if all parties behave correctly, then the protocol indeed behaves as expected [...]. For soundness

\section{Cryptography}

[TODO: public key cryptography]

[TODO: hash functions]


\section{Transactional Layer}

In this section we define a generalized view of transactional semantics of a blockchain system. The two foundational concepts here is a \textit{state} and a \textit{transaction}.

\subsection{Minimal State}     % section 1.1
	Consider a transaction arrived at a node. The node is doing following on receiving it:

    \begin{enumerate}
		\item Checks whether a transaction is valid
		\item Apply it if so
    \end{enumerate}

	Intuitively, there are some stateless checks, e.g. whether a signature for a transaction is valid, whether amount of tokens to transfer is non-negative, but also there are stateful ones. For example, if Alice is sending tokens to Bob, a node must be sure Alice has enough funds in order to make a payment. Or, if Alice is registering a domain, a node must be sure it is not taken yet. 

	So a node needs to store some state in order to validate incoming transactions. And there is some \textit{minimal state} representation enough to validate an arbitrary transaction while removing any element from the representation eliminating this property. So all the nodes share this minimal state but a node could also store some additional information. 

	By applying a transaction a minimal state is being modified. It should be impossible to apply a transaction already processed. 

	For many reasons almost all cryptocurrencies of today are packing transactions into \textit{blocks}. We can think about a block as of \textit{atomic batch state update}. 

    [TODO: Block header - tx part]


	We can state some axioms here.

	\begin{axiom}
	 There is some initial state hard-coded into each node. Further we name it \textit{genesis state}.
	\end{axiom}

    \begin{axiom} 
     Validation and application of a transactions(and possibly an additional metadata) are deterministic procedures. All the honest nodes follow the same rules. 
    \end{axiom}

	\begin{proposition} If the same sequence of blocks is applied to the genesis state for two different nodes, then the resulting minimal states will be the same.
	\end{proposition}	
	\begin{proof}Consider the nodes have the same minimal state and trying to apply the same block to it. By the Axiom 2, they will have the same minimal state as result, as verification and application procedures are deterministic. By the Axiom 1, genesis state is the same for all the nodes. By induction, result of sequential applying of the blocks results in the same minimal states for all the nodes.\end{proof}

Further we will use both the terms ``minimal state'' and ``state'' interchangeably. 


\subsection{Bitcoin}

In Bitcoin a transaction contains multiple \textit{inputs} and \textit{outputs}. Inputs are connected with outputs of transactions previously applied to a state, and the connected outputs must not be spent yet. That is, the outputs to be connected by the inputs of the transactions do not have connections from transactions previously applied to the state. Thus an output could be spent as whole only and so we can consider a set of unspent outputs as a minimal state.

How to spend an output? In Bitcoin it contains a script in a stack-based language. Input also contains a script. Then an input could spend an output if a combined script made of inputs' and then outputs' could be executed and results in non-zero top stack item.

[TODO: example]

\subsection{Boxes, Propositions and Proofs}

Abstracting the Bitcoin-like model, a minimal state could be represented as a set of \textit{closed boxes} of size \(n_S\). Each box has a value associated with it. Say, a transaction opens \(n_k\) boxes and also creates \(n_b\) new closed boxes, then the resulting state set has the size of \(n_S-n_k+n_b\) after applying the transaction to it. 

How to open a box? We can protect a box with a script in Bitcoin language. Or we can put a public key into closed box and then it is possible to open it with a proof of private key knowledge, a signature~(we will consider details further). To describe these approaches as well as many others possible in a general way, we say a box is protected by a \textit{proposition} of some kind, and in order to open it, a \textit{proof} of the same kind must be provided. There are some tricky details we will discuss further.

A box can has some additional to a value data inside. For example, it can contain a domain record or a certificate. Anyway, box contents matters for every full node until it is closed. 

\subsection{Namecoin}

Namecoin is a descendant of Bitcoin which in addition to token transfers, introduce \textit{name} $\rightarrow$ \textit{value} storage. In general, values could be arbitrary, but there are few  standard namespaces with predefined semantics, for domains and identities.

We do not specify Namecoin design precisely below, but some Namecoin-like design. 

Consider a transaction contains a box with \textit{name\_register} command specifying a \textit{name} $\rightarrow$ \textit{value} correspondence. Such a box has zero value and associated with a public key \(pk\). It is demanded to pay some fee in order to put such a box into state. The box lives in the state for some period of time, then it is considered as expired and could be thrown away from a minimal state. It is possible to renew or transfer ownership to a different public key by publishing a \textit{name\_update} box replacing an original one in the state.

This design has a critical flow. A block generator could refuse to include \textit{name\_register} command into a block and put its own value for the same name. This is an example of \textit{frontrunning attack}, when an original transaction is suppressed by another one issued by an attacker. In order to avoid frontrunning attacks, Namecoin has \textit{name\_new} command to announce the intention to register a name by providing its hash value.


\subsection{Nxt and Ethereum}	

Having a Bitcoin wallet, you can be goggled by complexity of boxes and propositions in form of stack-based scripts. Why not to have just accounts and token transfers between them instead? 

Actually some of Bitcoin successors walked this path. For example, Nxt has a dedicated notion of accounts. An account is associated with its public key. A transaction transfers tokens from one account to another and needed to be signed by the sender. For such a system stateful verification needs for a minimal state in form of table holding a correspondence between accounts and their balances.

With such a simple minimal state design we have a problem though. Let's describe it with an example. Alice has 50 tokens at some moment of time. She issues a signed transaction to pay 5 tokens to Bob. A node can validate the transaction and found it valid, and so applicable. After the application Alice has 45 tokens. But how to prevent second application of the transaction? Our minimal state representation seems to be flawed.

Ethereum solves the problem by modifying minimal state representation adding ``nonce'' value to it. That is, minimal state is not about (public key $\rightarrow$ balance) correspondence anymore, but (public key $\rightarrow$ (nonce, balance)). Transaction contains nonce value \(txnonce\) as well, and transaction is valid and so applicable only if \(txnonce = nonce + 1\). By application, \(nonce := txnonce\). 

Unlike Bitcoin, Ethereum sets strict order of transactions issued by an account. In Bitcoin, transactions could be applied in any order, 
if they are spending non-overlapping sets of outputs, and input of one transaction does not spend an output of another. In Ethereum, order of transaction is set by nonce values. 



\subsection{Transactional Metadata}

Assume we have a set of objects serializable to a set of unique byte arrays. We want to \textit{authenticate} these binary representations in an efficient. That is, we want to calculate a fixed-sized value for a whole set such as a single bit change always results in a change of the \textit{authenticating}~(or \textit{root}) value, and the value is collision-resistant, so it is impossible(with non-negligible probability) to generate different set resulting in the same root value. 

[TODO: Merkle tree / authenticated data structures explanation]

Along with transactions, we can put some aggregated data about them. For example. in Bitcoin's block a root hash of a Merkle tree for the transactions in block is put into the block. That way it is possible for nodes in a network to exchange not full blocks but \textit{blockheaders}. A \textit{blockheader} is a block without its transactions. By including transactions root hash into the blockheader it is possible to have it spread around a network and be sure it is impossible to show transactions set other that was included. 

[TODO: Bitcoin example]

\subsection{Transactional Layer Generalization}

After the examples, let's summarize what we have in common in all the observable cryptocurrencies.

\begin{enumerate}
\item{\textbf{A Proposition And A Proof.}}
In an every imaginable blockchain we have objects to be protected by secret owners. To achieve the property of being protected we introduce a proposition, and an object could be modified or destroyed only by presenting a proof satisfying a proposition. There are a lot of possible instantiations, e.g. Bitcoin scripts or digital signatures. 
\item{\textbf{Box Structure.}}
There is a minimal element of a replicated state we are calling a \textit{box}. A box is protected by a proposition. It is possible to modify it or destroy it only by showing a proof satisfying a proposition. 
\item{\textbf{Minimal State.}}
Minimal state is a most compact structure giving an ability to verify a transaction against it. Minimal state is about a set of boxes. 
\item{\textbf{Transaction And Transactional Language.}}
Transaction is a smallest possible atomic state modifier. A transaction is to be verified against a state in a deterministic fashion~(so given a state and a transaction, two nodes will always give the same validation result whether \textit{true} or \textit{false}). If a transaction is valid against a state it could modify the state. Validation and application rules are individual~(Ethereum even brings quasi Turing completeness here).
\item{\textbf{Block.}}
All the blockchain systems are storing transactions in full blocks. Most of them also have some authenticating value for the set of block transactions included into block thus it is possible to use block headers instead of full blocks in many scenarios in order to reduce a load.
\end{enumerate}


[TODO: wallet section?]

\section{Consensus}

We have proven(in the proposition~[?]) that if the same sequence of blocks carrying transactions is applied to the same genesis state for two node then they will have the same state. It is exactly what do we want to achieve, but how to have the same sequence of blocks for all the nodes? 

In the first place, we can achieve this only for nodes willing to achieve this by following some protocol strictly. We refer to such nodes as to \textit{honest} nodes, and to the protocol as to \textit{consensus protocol}. If nodes are not following the protocol we call them \textit{byzantine} nodes. A byzantine node could be malicious, but also it could be not able to follow the consensus protocol because of software bugs, problems with connectivity, misleading information sent from outer world etc. 

[validity, agreement, termination]

Computer Science studies consensus protocols since early 1980s. A lot of interesting results were generated in this field. For example, it is impossible to achieve consensus using a deterministic procedure for a set of nodes if they are exchanging messages asynchronously and a single process could fail(Fischer-Lynch-Paterson theorem~\cite{fischer1985impossibility}). 

Consensus in open networks, so with unknown number of participants, is pretty new and very hard question. 

\begin{enumerate}
\item{Validity}
\item{Agreement}
\item{Termination}
\end{enumerate}

For a blockchain consensus protocols, we can state following properties:

\begin{enumerate}
\item{Consistency(or Prefix immutability)} - for two honest nodes the probability to have different prefixes after cutting last \(k\) blocks should go down with \(k\) and be negligible after some value. The good option is to have the probability going down exponentially with \(k\).
\item{Chain Quality} - a party having \(x\%\) of voting power should produce no more than \((\alpha \cdot) x \%\) blocks in a long run, where \(\alpha\) is constant.
\item{Chain Growth} - over time blockchain should always grow. No one is interested in a structure with possibility to stuck. 
\end{enumerate}


\subsection{Proof-of-Work}

Proof-of-Work consensus protocol introduced in the foundational paper of Bitcoin~\cite{Nakamoto2008} is in the core of Bitcoin, Ethereum as well as many other cryptocurrencies. The basic idea of the protocol is to force miners to iterate over output of some function with a small probability of success per iteration. A successful result is giving a right to generate a block. The probability is adjusted automatically via \textit{difficulty} parameter \(D\). 

In case of Bitcoin, the function is just a hash function, but what is about its input? 

We want to make blocks immutable after creation. For that, we are applying hash function for all the block contents. 

[TODO: Merkle tree]

We also want for a block to refer to a previous block. So we include a hash of a previous block, in this case it in order to replace a block with another one it is needed to replace all its descendants also. As some amount of work is needed to generate each block in order to replace a chain suffix of length \(l\), amount of work proportional to \(l\) is needed.

With Proof-of-Work it is impossible to make a false claim on successful block generation. Such a claim is easily verifiable, as calling hash function is very cheap. Thus a Proof-of-Work works as a protection against Sybil attacks~\cite{}.

\subsection{Proof-of-Stake}

There are some disadvantages of Proof-of-Work schemes. A lot of resources to be spent. During early days a Proof-of-Work currency could be destroyed by a miner already having a lot of computational resources working for another blockchain. 

Can we have a protection against Sybil attacks without spending computational resources? The simplest way to achieve this is to use cryptocurrency tokens as anti-Sybil tools. That is, a probability to generate a block is proportional to a stake a node holds. 



\subsection{History}

Previously we talked about a blockchain. But in all the global networks collisions are possible~(to prevent them we need to have a global lock or synchronous rounds and then some kind of leader election). So in a network a \text{blocktree} lives.

[TODO: a blocktree picture]

In most cases the fact of blocktree existence in omitted. A node is storing a blockchain. A blockchain has some score(e.g. a chain length, but this is a totally insecure scoring function, see~\cite{stackexchange} for details). If better chain is declared in network, a node is throwing away blocks until common block and then apply better suffix. In this case a node sees a blocktree only during switching from one branch of it to another. There are some proposals to explicitly use a blocktree. For example, in GHOST scoring function~\cite{sompolinsky2015secure} a chain with heaviest tree wins. 


\subsection{Consensus Layer Generalization}

\section{Peer-to-Peer Network}	

Blockchain is maintained in a peer-to-peer network. For simplicity we are starting with a network where all the nodes 

\section{Incentives}



\section{Complications}

fully prunable outputs 
ZCash

\section{Conclusion}


\section{Further Reading}

Proof-of-Work and blockchain were introduced in the foundational Bitcoin whitepaper~\cite{Nakamoto2008}.

Overview of Bitcoin P2P layer along with description of possible Eclipse attacks(partly fixed to the moment) against it could be found in~\cite{heilman2015eclipse}


\chapter{Scorex}           % chapter 2
\section{Introduction}     % section 2.1

Scorex is a modular blockchain core framework. It supports definitions given in the previous chapter in form of Scala code. What do you need to do in order to build something on Scorex, is to implement all the abstract interfaces, or just some of them and use ready modules for missing parts.

\subsection{*Scala Language}         % subsection 2.1.1

We will describe some concepts of Scala language in sections started with ``*''. If you already a Scala developer, you can miss the sections. Experience with programming languages(say, Java, C++, OCaml or Rust) is needed, as we will explain Scala features used in code snippets provided very quickly. For a good introduction into the Scala language, please refer to~\cite{odersky2008programming}.

Scala is functional, modular and also object-oriented language. Such a mix of concepts means different developers can follow very different styles. 

There are several reasons for choosing Scala:
\begin{enumerate}
	\item Scala runs on the JVM which allows it to be cross-platform.
	\item Scala inter-operates seamlessly with Java.
	\item Scala is fully functional and consequently allows compact and more readible code.
	\item Scala has powerful constructs for concurrency.
	
\end{enumerate}

[TODO: quick description]

\section{Transactional Layer}

Transactional layers describes blockchain semantics. That is, what is a minimal state enough to validate incoming transactions, what is transaction and how processing of it affects the state, how transactions are protected from being spent by non-allowed party, how wallet is organized etc

\subsection{*Scala: Traits and Type Parameters}

The basic piece in a sufficiently large Scala codebase is a \textit{trait}. Trait is an abstract(so non-instantiable) interface describing functions and values a concrete implementation(class or object) must provide to its users. We can also think about trait as of type and also a parametrized module. A trait could be parametrized not only by values, but also by types. 

Quick example: 
[TODO: example]

\subsection{Propositions and Proofs}

In the first place, we are getting into a mechanism to protect binary objects, e.g. transaction outputs, from non-permissioned access. We protect an object with a \textit{proposition}. Then in order to make an action with an object it is needed to provide a \textit{proof} for its proposition. 

Proposition is very abstract concept. The only property we require from it is to be serialized into bytes. In form of Scala code it is described as:

\begin{lstlisting}
trait Proposition extends BytesSerializable
\end{lstlisting}

In most useful scenarios a proposition should be addressable. That is, it could be addressed by some identifier, or identifiers.

A proof is an object which could satisfy a proposition given an additional input, namely a \textit{message}(e.g. transaction bytes). As well as a proposition, a proof could be serialized into bytes. 

\begin{lstlisting}
trait Proof[P <: Proposition] extends BytesSerializable {
  def isValid(proposition: P, message: Array[Byte]): Boolean
  ...
}
\end{lstlisting}


\subsection{Box}

A box is a minimal state element. An unspent output in Bitcoin is a box. An account in certain state in Nxt or Ethereum is also a box. Basically, a box is about some value(how many system tokens are associated with it), and some proposition which protects a box from being spent by anyone but a party(or parties) knowing how to satisfy the proposition.

\begin{lstlisting}
trait Box[P <: Proposition] extends BytesSerializable {
  val proposition: P

  val value: Long

  val id: Array[Byte]
}
\end{lstlisting}


\subsection{*Scala: Sum Types and Try}

\subsection{A Transaction and Minimal State}

As it was shown in the Chapter 1[TODO: link], a transaction and a minimal state could be defined via each other: a transaction is a state modifier, which also could be valid or not against a state, and applicable if and only if it is valid. A minimal state is a data structure which deterministically defines whether an arbitrary transaction is valid and so applicable to it or not. 

\begin{lstlisting}
abstract class Transaction[P <: Proposition, TX <: Transaction[P, TX]] extends BytesSerializable with JsonSerializable {
  def validate(state: MinimalState[P, TX]): Try[Unit]
  def changes(state: MinimalState[P, TX]): Try[StateChanges[P]]

  ...
}
\end{lstlisting}

We are defining functional interface for minimal state below:

\begin{lstlisting}
trait MinimalState[P <: Proposition, TX <: Transaction[P, TX]] {
  def version: Int

  def isValid(tx: TX): Boolean = tx.validate(this).isSuccess

  def processBlock(block: Block[P, _, _]): Try[Unit]
  def rollbackTo(height: Int): Try[Unit]

  def closedBox(boxId: Array[Byte]): Option[Box[P]]

  ...
}
\end{lstlisting}

So a minimal state knows its current version, can apply a block, and also rollback to a previous version. To validate a transaction, it just calls \textit{validate} function of a transaction and checks its result.

\subsection{Wallet}

[TODO:]

\subsection{Memory Pool}

\begin{lstlisting}
trait UnconfirmedTransactionsDatabase[TX <: Transaction[_, TX], TData <: TransactionalData[TX]] {
  def putIfNew(tx: TX): Boolean

  def all(): Seq[TX]

  def getById(id: Array[Byte]): Option[TX]

  def packUnconfirmed(): TData

  def clearFromUnconfirmed(data: TData): Unit

  def onNewOffchainTransaction(transaction: TX): Unit

  def remove(tx: TX)
  
}
\end{lstlisting}

\subsection{Transactional Block Data}

\begin{lstlisting}
trait TransactionalData[TX <: Transaction[_, TX]] extends BytesSerializable with JsonSerializable {
  val mbTransactions: Option[Traversable[TX]]

  val headerOnly = mbTransactions.isDefined
  ....
}
\end{lstlisting}

\subsection{Transactional Module}



\section{Consensus Layer}

\subsection{Block}

\begin{lstlisting}
class Block[P <: Proposition, TData <: TransactionalData[_ <: Transaction[P, _]], CData <: ConsensusData](
                                                                                      val version: Byte,
                                                                                      val timestamp: Long,
                                                                                      val consensusData: CData,
                                                                                      val transactionalData: TData)
\end{lstlisting}

\subsection{History and Blockchain}

\section{Network Layer}

Network layer in Scorex is simpler than in Bitcoin or Nxt. 

\subsection{Peer Discovery}

\subsection{Broadcasting Strategies}

\subsection{View Synchronizing}

\section{Ready Modules}
There are few modules already implemented.

\subsection{Proof-of-Stake}
Proof-of-Stake module contains implementations of two Proof-of-Stake consensus algorithms. 

\subsection{Simple Transactions Module}

Simplest Transactions Module contains an implementation of transactional module with only one kind of transactions, just tokens transfers from one public key to another.

\subsection{Permacoin Implementation Module}

The module contains an implementation of Permacoin consensus protocol~\cite{miller2014permacoin}.

\section{Conclusion}

\bibliographystyle{plain}
\bibliography{sources}

\end{document}	